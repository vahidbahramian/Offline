#pragma once
/*
	FIR Implementation Using Overlap Add Method
*/

#include "func_interv.h"
#include "mkl_vml.h"
#include "mkl_types.h"
#include "mkl_cblas.h"
#include "mkl_dfti.h"
#include <Windows.h>
#define  _USE_MATH_DEFINES
#include <math.h>
#include "dsplib_fir_design.h"
#include "dsplib_general_func.h"
#include "MovingAverage.h"

#define _DSPLIB_FIR_OLA

//#define _FIR_OLA_SAVE_COEFS //used for save coefficients generated by CreateBPF()
#define _FIR_OLA_COEFS_FILE "c:\\samples\\coef.txt"

namespace NS_DSP
{

//Single Presicion class
class CFIROLAvmls
{
public:
	CFIROLAvmls(void);
	~CFIROLAvmls(void);

	void Reset();
	void Release();
	BOOL Create(int nSizeFFT,int nTapSize , float *m_fCoeffs);
	BOOL CreateBPF(int nSizeFFT,int nTapSize , float fStart,float fStop,float fs, int flags = BP|HAMMING);
	BOOL Filter(float *m_fInput, int nInputSize, float *m_fOutput,int &nOutSize);

	DFTI_DESCRIPTOR_HANDLE m_pDescFFT ;
	DFTI_DESCRIPTOR_HANDLE m_pDescIFFT;

	MKL_Complex8 *m_cCoefsFFT;
	MKL_Complex8 *m_cDataFFT;
	MKL_Complex8 *m_cOutFFT;

	float *m_fCoefficients;
	float *m_fInputBlock;
	float *m_fOutIFFT;
	float *m_fLastOutOverlap;
	int m_nTapSize;//M
	int m_nFFT;//N 
	int m_L;//N-M+1 overlap length

	int m_nBlockIndex;
};

//Double Precision Class
class CFIROLAvmld
{
public:
	CFIROLAvmld(void);
	~CFIROLAvmld(void);

	void Reset();
	void Release();
	BOOL Create(int nSizeFFT,int nTapSize , double *m_fCoeffs);
	BOOL CreateBPF(int nSizeFFT,int nTapSize , double fStart,double fStop,double fs, int flags = BP|HAMMING);
	BOOL Filter(double *m_fInput, int nInputSize, double *m_fOutput,int &nOutSize,BOOL bDivDcFft = FALSE);
	BOOL FilterAndDelay(double *m_fInput, int nInputSize, double *m_fOutput,double *m_fDelay,int &nOutSize);
	BOOL FilterAndDelay(double *m_fInput, int nInputSize,double *m_fOutput,	double *m_fDelay,int &nOutSize,double *m_fOutAbs,double *m_fOutSqr);
	BOOL FilterAndDelaySSBHopping(double *m_fInput, int nInputSize, double *m_fOutput,int *m_iHopSeq,int *m_iHopSeqDelay,int &nOutSize);
	BOOL FilterForFirstFrame(double *m_fInput, int nInputSize, double *m_fOutput,MKL_Complex16 *cOutFFT,int &nOutSize);
// 	BOOL NoiseEstimation(int SubMinSegs,int NumberSetps,double *Coef,double *input,double *noisePSD,double *a2FFT);


	DFTI_DESCRIPTOR_HANDLE m_pDescFFT ;
	DFTI_DESCRIPTOR_HANDLE m_pDescIFFT;

	MKL_Complex16 *m_cCoefsFFT;
	MKL_Complex16 *m_cDataFFT;
	MKL_Complex16 *m_cOutFFT;

	double *m_fCoefficients;
	double *m_fInputBlock;
	double *m_fOurBufferMA;
	double *m_fOutIFFT;
	double *m_fLastOutOverlap;
	double *m_fOutAbs;
	double *m_fOutSqr;
	int m_nTapSize;//M
	int m_nFFT;//N 
	int m_L;//N-M+1 overlap length

	int m_nBlockIndex;
	int m_nDelayIndex;
	BOOL m_bResetDelayBuffer;
	int m_nLastOutSize;
	BOOL m_bIsFilter;

	int			m_nSubSegIdx;
	BOOL		bIsCalcMinima;
	double		*m_fFreqNoiseFlag;
	double		*m_fSFrame;
	double		*a2FFTSmoothed;
	double		*minimaA2SubSeg;
	double		m_fDCFftBackward;

	//CMovingAverage<double> m_objMA500;

};

}//namespace
